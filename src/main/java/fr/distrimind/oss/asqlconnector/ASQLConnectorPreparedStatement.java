package fr.distrimind.oss.asqlconnector;

import android.database.Cursor;
import fr.distrimind.oss.flexilogxml.common.FlexiLogXML;

import java.io.*;
import java.math.BigDecimal;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.sql.*;
import java.sql.Date;
import java.util.*;

public class ASQLConnectorPreparedStatement implements PreparedStatement {

	public static final String NOT_IMPLEMENTED = "not implemented";
	/**
	 * The value used for autoGeneratedKeys in Connection.prepareStatement. Defaults to NO_GENERATED_KEYS
	 */
	private final int autoGeneratedKeys;
	protected ASQLConnectorDatabase db;
	protected ASQLConnectorConnection aSQLConnectorConnection;
	protected ASQLConnectorResultSet rs = null;
	protected String sql;
	@SuppressWarnings("PMD.LooseCoupling")
	protected ArrayList<Object> l = new ArrayList<>();
	protected List<List<Object>> lBatch = new ArrayList<>();
	/**
	 * True if the sql statement is a select.
	 */
	protected boolean isSelect;

	/**
	 * True if the sql statement MAY produce a result set.  For example, "create" and "drop" command will
	 * produce a "false" value for this.
	 */
	protected boolean potentialResultSet;
	private Integer maxRows = null;
	/**
	 * The update count.  We don't know this, but need to respond in such a way that:
	 * (from getMoreResults) There are no more results when the following is true:
	 * // stmt is a Statement object
	 * ((stmt.getMoreResults() == false) &amp;&amp; (stmt.getUpdateCount() == -1))
	 * <p>
	 * This is used by <code>getUpdateCount()</code>.  If there is a resultSet
	 * then getUpdateCount will return -1.  If there is no result set, then, presumably,
	 * <code>execute()</code> was called and we have one result and so can return something
	 * other than -1 on the first call to getUpdateCount.   In this case, the second call to getUpdateCount
	 * we should return -1;
	 * We set this to zero on execute() and decrement it on getUpdateCount.  If the value of updateCount
	 * is -1 then we just return it from getUpdateCount.
	 */
	private int updateCount = -1;
	/**
	 * The ResultSet object containing the last row id generated by the database when executing
	 * an INSERT statement.
	 */
	private ResultSet rowIdResultSet = null;
	private boolean poolable = false;
	private boolean closed = false;

	public ASQLConnectorPreparedStatement(String sql, ASQLConnectorConnection asqlconnector, int autoGeneratedKeys) {
		this.autoGeneratedKeys = autoGeneratedKeys;
		Log.trace(() -> "new ASQLConnector prepared statement from " + asqlconnector);
		this.aSQLConnectorConnection = asqlconnector;
		this.db = asqlconnector.getDb();
		setSQL(sql);
	}

	@SuppressWarnings({"unused"})
	private void ensureCap(int n) {
	}

	private void setObj(int n, Object obj) {
		l.ensureCapacity(n);
		int additions = n - l.size();
		for (int i = 0; i < additions; i++) {
			l.add(null);
		}

		l.set(n-1, obj);
	}

	@Override
	public void addBatch(String sql) {
		//sql must be a static sql
		setSQL(getSQL() + sql);
	}

	/**
	 * @return the sql
	 */
	public String getSQL() {
		return sql;
	}

	/**
	 * @param sql the sql to set
	 */
	public void setSQL(String sql) {
		// this is loosely based on the codee in ASQLConnectorStatement
		this.sql = sql;
		isSelect = sql.toUpperCase(FlexiLogXML.getLocale()).matches("(?m)(?s)\\s*SELECT.*");
		// examples of a failure on the next line (so isSelect is false and potentialResultSet remains true, are PRAGMA and INSERT (why INSERT?)
		potentialResultSet = isSelect || (!sql.toUpperCase(FlexiLogXML.getLocale()).matches("(?m)(?s)\\s*CREATE.*") && !sql.toUpperCase(FlexiLogXML.getLocale()).matches("(?m)(?s)\\s*DROP.*"));
	}


	@Override
	public void cancel() throws SQLException {
		// TODO: This is simplemented by Xerial
		throw new SQLFeatureNotSupportedException("cancel is not supported");
	}

	@Override
	public void clearBatch() {
		lBatch = new ArrayList<>();
	}

	@Override
	public void clearWarnings() {
		// TODO: Evaluate if implementation is sufficient (if so, delete comment and log)
		Log.error(() -> " ********************* not implemented @ "
				+ DebugPrinter.getFileName() + " line "
				+ DebugPrinter.getLineNumber());
	}

	@Override
	public void close() throws SQLException {
		closed = true;
		try {
			if (rs != null) {
				rs.close();
			}
		} finally {
			rs = null;
		}
	}

	private String[] makeArgListQueryString() throws SQLException {
		if (l == null || l.isEmpty()) {
			return new String[0];
		}
		// convert our parameter list objects to strings
		String[] t=new String[l.size()];
		int i=0;
		for (Object o : l) {
			if (o==null)
				t[i++]=null;
			else if (o.getClass()==byte[].class)
				throw new IllegalAccessError();
			else if (o instanceof ASQLConnectorClob)
				throw new IllegalAccessError();
			else if (o instanceof ASQLConnectorBlob)
				throw new SQLException();
			else
				t[i++]=o.toString();
		}
		return t;
	}

	private Object[] makeArgListQueryObject() {
		return l.toArray();
	}

	@Override
	@SuppressWarnings("PMD.CloseResource")
	public boolean execute() throws SQLException {
		updateCount = -1;
		closeResultSet();
		// problem, a PRAGMA statement (and maybe others) should also cause a result set
		if (!isSelect && sql.toUpperCase(FlexiLogXML.getLocale()).matches("(?m)(?s)\\s*PRAGMA.*")) {
			isSelect = true;
		}
		this.aSQLConnectorConnection.startAutoTransactionIfNecessary();
		try {
			if (isSelect) {
				String limitedSql = sql + (maxRows != null ? " LIMIT " + maxRows : "");
				Cursor c = db.rawQuery(limitedSql, makeArgListQueryString());
				rs = new ASQLConnectorResultSet(c);
			} else {
				db.execSQL(sql, makeArgListQueryObject());
				updateCount = aSQLConnectorConnection.changedRowsCount();
			}
		}
		catch (SQLException e)
		{
			this.aSQLConnectorConnection.endAutoTransactionIfNecessary(false);
			throw e;
		}
		this.aSQLConnectorConnection.endAutoTransactionIfNecessary(true);

		return isSelect;
	}

	/**
	 * Close the result set (if open) and null the rs variable.
	 */
	public void closeResultSet() throws SQLException {
		if (rs != null && !rs.isClosed()) {
			if (!rs.isClosed()) {
				rs.close();
			}
			rs = null;
		}
	}

	@Override
	@SuppressWarnings("PMD.CloseResource")
	public ResultSet executeQuery() throws SQLException {
		updateCount = -1;
		closeResultSet();
		// Log.debug(() -> "executeQuery " + sql);
		// when querying, all ? values must be converted to Strings for some reason
		this.aSQLConnectorConnection.startAutoTransactionIfNecessary();
		Cursor c;
		try {
			c = db.rawQuery(sql, makeArgListQueryString());
		}
		catch (SQLException e)
		{
			this.aSQLConnectorConnection.endAutoTransactionIfNecessary(false);
			throw e;
		}
		this.aSQLConnectorConnection.endAutoTransactionIfNecessary(true);
		// Log.debug(() -> "executeQuery " + 2);
		rs = new ASQLConnectorResultSet(c);
		// Log.debug(() -> "executeQuery " + 3 + ": " + rs);
		return rs;
	}
	private void checkNotInSelect() throws SQLException {
		if (isSelect)
			throw new SQLException("The SQL query is not an update query : "+sql);
	}
	@Override
	public int executeUpdate() throws SQLException {
		checkNotInSelect();
		execute();
		if (autoGeneratedKeys == PreparedStatement.RETURN_GENERATED_KEYS) {
			rowIdResultSet = aSQLConnectorConnection.getGeneratedRowIdResultSet();
			return updateCount==-1?0:updateCount;
		}
		return updateCount;
	}

	@Override
	public boolean execute(String sql) throws SQLException {
		setSQL(sql);
		return execute();
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		throw new SQLFeatureNotSupportedException(NOT_IMPLEMENTED);
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		throw new SQLFeatureNotSupportedException(NOT_IMPLEMENTED);
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		throw new SQLFeatureNotSupportedException(NOT_IMPLEMENTED);
	}

	@Override
	public int[] executeBatch() throws SQLException {
		int[] results = new int[lBatch.size()];
		updateCount = -1;
		this.aSQLConnectorConnection.startAutoTransactionIfNecessary();
		try {
			for (int i = 0; i < lBatch.size(); i++) {

				results[i] = EXECUTE_FAILED;
				db.execSQL(sql, lBatch.get(i).toArray());
				results[i] = aSQLConnectorConnection.changedRowsCount();
				if (updateCount == -1)
					updateCount = results[i];
				else
					updateCount += results[i];
			}
		}
		catch (SQLException e)
		{
			this.aSQLConnectorConnection.endAutoTransactionIfNecessary(false);
			throw e;
		}
		this.aSQLConnectorConnection.endAutoTransactionIfNecessary(true);
		return results;
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		setSQL(sql);
		return executeQuery();
	}


	@Override
	public int executeUpdate(String sql) throws SQLException {
		setSQL(sql);
		return executeUpdate();
	}

	@Override
	public int executeUpdate(String thisSql, int autoGeneratedKeys) throws SQLException {
		checkNotInSelect();
		this.aSQLConnectorConnection.startAutoTransactionIfNecessary();
		int r;
		try {
			db.execSQL((thisSql != null) ? thisSql : sql, makeArgListQueryObject());
			if (autoGeneratedKeys == PreparedStatement.RETURN_GENERATED_KEYS) {
				// Capture the generated rowId immediately after executing the (insert) statement
				rowIdResultSet = aSQLConnectorConnection.getGeneratedRowIdResultSet();
				updateCount = aSQLConnectorConnection.changedRowsCount();
			}
			r=aSQLConnectorConnection.changedRowsCount();
		}
		catch (SQLException e)
		{
			this.aSQLConnectorConnection.endAutoTransactionIfNecessary(false);
			throw e;
		}
		this.aSQLConnectorConnection.endAutoTransactionIfNecessary(true);
		return r;
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		throw new SQLFeatureNotSupportedException(NOT_IMPLEMENTED);
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		throw new SQLFeatureNotSupportedException(NOT_IMPLEMENTED);
	}

	@Override
	public Connection getConnection() {
		return aSQLConnectorConnection;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		// TODO: Ensure that this doesn't throw NPE
		return rs.getFetchDirection();
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		// TODO: Avoid NPE
		rs.setFetchDirection(direction);
	}

	@Override
	public int getFetchSize() throws SQLException {
		// TODO: Ensure that this doesn't throw NPE
		return rs.getFetchSize();
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		// TODO: Avoid NPE
		rs.setFetchSize(rows);
	}

	@Override
	public ResultSet getGeneratedKeys() {
		if (rowIdResultSet==null)
			return ASQLConnectorEmptyResultSet.SINGLETON;
		ResultSet tmp = rowIdResultSet;
		rowIdResultSet = null;  // so the next time it would be returned as null
		return tmp;
	}

	@Override
	public int getMaxFieldSize() {
		return 0;
	}

	@Override
	public void setMaxFieldSize(int max) {
		throw new UnsupportedOperationException("Not implemented yet");
	}

	@Override
	public int getMaxRows() {
		return maxRows;
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
		ensureNotClosed();
		if (max < 0) {
			throw new SQLException("Max rows must be zero or positive. Got " + max);
		} else if (max == 0) {
			maxRows = null;
		} else {
			maxRows = max;
		}
	}

	@Override
  /* There are no more results when the following is true:

	     // stmt is a Statement object
	     ((stmt.getMoreResults() == false) && (stmt.getUpdateCount() == -1))*/
	public boolean getMoreResults() throws SQLException {
		return getMoreResults(CLOSE_CURRENT_RESULT);
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		if (current == CLOSE_CURRENT_RESULT) {
			closeResultSet();
		}
		return false;
	}

	@Override
	public int getQueryTimeout() {
		return 0;
	}

	@Override
	public void setQueryTimeout(int seconds) {
		throw new UnsupportedOperationException("setQueryTimeout not implemented");
	}

	@Override
	public ResultSet getResultSet() {
		return rs;
	}

	@Override
	public int getResultSetConcurrency() {
		return ResultSet.CONCUR_READ_ONLY;
	}

	@Override
	public int getResultSetHoldability() {
		return ResultSet.CLOSE_CURSORS_AT_COMMIT;
	}

	@Override
	public int getResultSetType() {
		return ResultSet.TYPE_FORWARD_ONLY;
	}

	/**
	 * Retrieves the current result as an update count; if the result is a ResultSet object or there are no more results, -1 is returned. This method should be called only once per result.
	 * Returns:
	 * the current result as an update count; -1 if the current result is a ResultSet object or there are no more results
	 */
	@Override
	public int getUpdateCount() {
		if (updateCount != -1) {  // for any successful update/insert, update count will have been set
			// the documentation states that you're only supposed to call this once per result.
			// on subsequent calls, we'll return -1 (which would appear to be the correct return
			int tmp = updateCount;
			updateCount = -1;
			return tmp;
		}
		return updateCount;  // if the result was a result set, or this is the second call, then this will be -1
	}

	@Override
	public SQLWarning getWarnings() {
		Log.error(() -> " ********************* not implemented @ "
				+ DebugPrinter.getFileName() + " line "
				+ DebugPrinter.getLineNumber());
		return null;
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		throw new SQLFeatureNotSupportedException("setCursorName not supported");
	}

	@Override
	public void setEscapeProcessing(boolean enable) {
		if (!enable) {
			throw new UnsupportedOperationException("setEscapeProcessing not implemented yet");
		}
	}

	private void ensureNotClosed() throws SQLException {
		if (isClosed()) {
			throw new SQLException("Statement is closed.");
		}
	}

	@Override
	public void addBatch() throws SQLException {
		lBatch.add(l);
		clearParameters();
	}

	@Override
	public void clearParameters() {
		l = new ArrayList<>();
	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		// TODO: Avoid NPE
		return rs.getMetaData();
	}

	@Override
	public ParameterMetaData getParameterMetaData() {
		throw new UnsupportedOperationException("getParameterMetaData not implemented");
	}

	@Override
	public void setArray(int parameterIndex, Array theArray) throws SQLException {
		throw new SQLFeatureNotSupportedException("setArray not supported");
	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream theInputStream, int length) throws SQLException {
		setAsciiStream(parameterIndex, theInputStream, (long) length);
	}

	@Override
	public void setBigDecimal(int parameterIndex, BigDecimal theBigDecimal) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, Utils.bigDecimalToString(theBigDecimal));
	}

	/**
	 * Set the parameter from the contents of a binary stream.
	 *
	 * @param parameterIndex the index of the parameter to set
	 * @param inputStream    the input stream from which a byte array will be read and set as the value.  If inputStream is null
	 *                       this method will throw a SQLException
	 * @param length         a positive non-zero length values
	 * @throws SQLException thrown if the length is &lt;= 0, the inputStream is null,
	 *                      there is an IOException reading the inputStream or if "setBytes" throws a SQLException
	 */
	@Override
	public void setBinaryStream(int parameterIndex, InputStream inputStream, int length) throws SQLException {
		if (length <= 0) {
			throw new SQLException("Invalid length " + length);
		}
		if (inputStream == null) {
			throw new SQLException("Input Stream cannot be null");
		}
		final int bufferSize = 8192;
		byte[] buffer = new byte[bufferSize];
		try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {

			int bytesRemaining = length;
			int bytesRead;
			int maxReadSize;
			while (bytesRemaining > 0) {
				maxReadSize = Math.min(bytesRemaining, bufferSize);
				bytesRead = inputStream.read(buffer, 0, maxReadSize);
				if (bytesRead == -1) { // inputStream exhausted
					break;
				}
				outputStream.write(buffer, 0, bytesRead);
				bytesRemaining = bytesRemaining - bytesRead;
			}
			setBytes(parameterIndex, outputStream.toByteArray());
		} catch (IOException e) {
			throw new SQLException(e.getMessage());
		}
	}

	@Override
	public void setBlob(int parameterIndex, Blob theBlob) throws SQLException {

		if (theBlob instanceof ASQLConnectorBlob)
			setBlobImpl(parameterIndex, (ASQLConnectorBlob)theBlob);
		else {
			long l=theBlob.length();
			if (l>Integer.MAX_VALUE-10)
				throw new SQLException();
			setBlobImpl(parameterIndex, new ASQLConnectorBlob(theBlob.getBytes(1, (int) l)));
		}
	}


	private void setBlobImpl(int parameterIndex, ASQLConnectorBlob theBlob) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theBlob);
	}

	@Override
	public void setBoolean(int parameterIndex, boolean theBoolean) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theBoolean?(short)1:(short)0);

	}

	@Override
	public void setByte(int parameterIndex, byte theByte) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theByte);
	}

	@Override
	public void setBytes(int parameterIndex, byte[] theBytes) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, Utils.getTypedBytesArray(theBytes));
	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
		setCharacterStream(parameterIndex, reader, (long) length);
	}

	@Override
	public void setClob(int parameterIndex, Clob theClob) throws SQLException {
		setBlobImpl(parameterIndex, new ASQLConnectorBlob(theClob));
		ensureCap(parameterIndex);
	}

	@Override
	public void setDate(int parameterIndex, Date theDate) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theDate.getTime());
	}

	@Override
	public void setDate(int parameterIndex, Date theDate, Calendar cal) {
		Calendar c=((Calendar)cal.clone());
		c.setTimeInMillis(theDate.getTime());
		ensureCap(parameterIndex);
		setObj(parameterIndex, c.getTimeInMillis());
	}

	@Override
	public void setDouble(int parameterIndex, double theDouble) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theDouble);
	}

	@Override
	public void setFloat(int parameterIndex, float theFloat) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theFloat);
	}

	@Override
	public void setInt(int parameterIndex, int theInt) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theInt);
	}

	@Override
	public void setLong(int parameterIndex, long theLong) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theLong);
	}

	@Override
	public void setNull(int parameterIndex, int sqlType) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, null);
	}

	@Override
	public void setNull(int paramIndex, int sqlType, String typeName){
		ensureCap(paramIndex);
		setObj(paramIndex, null);
	}

	@Override
	public void setObject(int parameterIndex, Object theObject) throws SQLException {
		ensureCap(parameterIndex);
		if (theObject==null)
			setObj(parameterIndex, null);
		else {
			if (theObject instanceof BigDecimal)
				setBigDecimal(parameterIndex, (BigDecimal) theObject);
			else if (theObject.getClass()==byte[].class)
				setBytes(parameterIndex, (byte[])theObject);
			else if (theObject instanceof Blob)
				setBlob(parameterIndex, (Blob)theObject);
			else if (theObject instanceof Clob)
				setClob(parameterIndex, (Clob)theObject);
			else if (theObject instanceof String)
				setString(parameterIndex, (String)theObject);
			else
				setObj(parameterIndex, theObject);
		}

	}

	@Override
	public void setObject(int parameterIndex, Object theObject, int targetSqlType) throws SQLException {
		setObject(parameterIndex, theObject);
	}

	@Override
	public void setObject(int parameterIndex, Object theObject, int targetSqlType, int scale) {
		setObj(parameterIndex, theObject);
	}

	@Override
	public void setRef(int parameterIndex, Ref theRef) throws SQLException {
		throw new SQLFeatureNotSupportedException("setRef not supported");
	}

	@Override
	public void setShort(int parameterIndex, short theShort) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theShort);
	}

	@Override
	public void setString(int parameterIndex, String theString) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, Utils.getTypedString(theString));
	}

	@Override
	public void setTime(int parameterIndex, Time theTime) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theTime.getTime());
	}

	@Override
	public void setTime(int parameterIndex, Time theTime, Calendar cal) {
		ensureCap(parameterIndex);
		Calendar c=((Calendar)cal.clone());
		c.setTimeInMillis(theTime.getTime());
		setObj(parameterIndex, c.getTimeInMillis());
	}

	@Override
	public void setTimestamp(int parameterIndex, Timestamp theTimestamp) {
		ensureCap(parameterIndex);
		setObj(parameterIndex, theTimestamp.getTime());
	}

	@Override
	public void setTimestamp(int parameterIndex, Timestamp theTimestamp, Calendar cal) throws SQLException {
		setTimestamp(parameterIndex, theTimestamp);
	}

	@Override
	public void setURL(int parameterIndex, URL theURL) throws SQLException {
		throw new SQLFeatureNotSupportedException("setURL not supported");
	}

	@Override
	@Deprecated
	public void setUnicodeStream(int parameterIndex, InputStream theInputStream, int length) throws SQLException {
		setCharacterStream(parameterIndex, new InputStreamReader(theInputStream, StandardCharsets.UTF_8), length);
	}

	@Override
	public boolean isClosed() {
		// TODO Evaluate if this is a sufficient implementation
		return closed;
	}

	@Override
	public boolean isPoolable() {
		return poolable;
	}

	@Override
	public void setPoolable(boolean poolable) {
		this.poolable = poolable;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) {
		return iface != null && iface.isAssignableFrom(getClass());
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		if (isWrapperFor(iface)) {
			return (T) this;
		}
		throw new SQLException(getClass() + " does not wrap " + iface);
	}


	@Override
	public void setAsciiStream(int parameterIndex, InputStream inputStream) throws SQLException {
		setAsciiStream(parameterIndex, inputStream, -1L);
	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream inputStream, long length) throws SQLException {
		setCharacterStream(parameterIndex, new InputStreamReader(inputStream, StandardCharsets.US_ASCII), length);
	}

	/**
	 * Read the byte stream and set the object as a byte[].  This is a pass through to
	 * <code>setBinaryStream(parameterIndex, inputStream, Integer.MAX_VALUE);</code>
	 *
	 * @see #setBinaryStream(int, InputStream, int)
	 */
	@Override
	public void setBinaryStream(int parameterIndex, InputStream inputStream) throws SQLException {
		setBinaryStream(parameterIndex, inputStream, Integer.MAX_VALUE);
	}

	/**
	 * This is a pass through to the integer version of the same method.  That is, the long is downcast to an
	 * integer.  If the length is greater than Integer.MAX_VALUE this method will throw a SQLException.
	 *
	 * @throws SQLException thrown if length is greater than Integer.MAX_VALUE or if there is a database error.
	 * @see #setBinaryStream(int, InputStream, int)
	 */
	@Override
	public void setBinaryStream(int parameterIndex, InputStream inputStream, long length) throws SQLException {
		if (length > Integer.MAX_VALUE) {
			throw new SQLException("DM-A-SQLConnector does not allow input stream data greater than " + Integer.MAX_VALUE);
		}
		setBinaryStream(parameterIndex, inputStream, (int) length);
	}

	@Override
	public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
		setBlob(parameterIndex, inputStream, -1);
	}

	@Override
	public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
		setBlob(parameterIndex, new ASQLConnectorBlob(inputStream, length));
	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
		setCharacterStream(parameterIndex, reader, -1);
	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
		try {
			int intValueOfChar;
			StringBuilder targetString = new StringBuilder();
			while ((intValueOfChar = reader.read()) != -1) {
				targetString.append((char) intValueOfChar);
			}
			setString(parameterIndex, targetString.toString());
		} catch (IOException e) {
			throw new SQLException("Failed to read reader.", e);
		}
	}

	@Override
	public void setClob(int parameterIndex, Reader reader) throws SQLException {
		setClob(parameterIndex, reader, -1);
	}

	@Override
	public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
		setBlob(parameterIndex, new ASQLConnectorBlob(reader, length));
	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader reader) throws SQLException {
		setNCharacterStream(parameterIndex, reader, -1);
	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
		setCharacterStream(parameterIndex, reader, length);
	}

	@Override
	public void setNClob(int parameterIndex, NClob value) throws SQLException {
		throw new SQLFeatureNotSupportedException("setNClob not supported");
	}

	@Override
	public void setNClob(int parameterIndex, Reader reader) throws SQLException {
		setNClob(parameterIndex, reader, -1);
	}

	@Override
	public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
		setClob(parameterIndex, reader, length);
	}

	@Override
	public void setNString(int parameterIndex, String theString) {
		setString(parameterIndex, theString);
	}

	@Override
	public void setRowId(int parameterIndex, RowId theRowId) throws SQLException {
		throw new SQLFeatureNotSupportedException("setRowId not supported");
	}

	@Override
	public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
		throw new SQLFeatureNotSupportedException("setSQLXML not supported");
	}

	// methods added for JDK7 compilation
	@SuppressWarnings("PMD")
	public boolean isCloseOnCompletion() throws SQLException {
		ensureNotClosed();
		return false;
	}

	@SuppressWarnings("PMD")
	public void closeOnCompletion() {
		// TODO Evaluate if this is a sufficient implementation (if so, remove this comment)
	}

}
